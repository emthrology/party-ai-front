# JWT 인증 보안 검토 보고서

## 🔴 심각한 보안 문제점

### 1. **클라이언트 사이드에서 JWT 생성**
**위치**: `utils/jwt.ts`, `mocks/handlers.ts`

**문제점**:
- JWT 토큰이 클라이언트(브라우저)에서 생성되고 있음
- 시크릿 키가 클라이언트 코드에 노출됨 (`SECRET = 'your-secret-key-change-in-production'`)
- 누구나 토큰을 위조할 수 있음

**영향**:
- 공격자가 임의의 사용자로 위장 가능
- 토큰 서명 검증이 무의미해짐

**해결책**:
- JWT 토큰은 **반드시 서버에서만** 생성해야 함
- 시크릿 키는 서버 환경 변수에 저장
- 클라이언트는 서버 API를 통해 토큰을 받아야 함

---

### 2. **약한 서명 알고리즘**
**위치**: `utils/jwt.ts:31-39`

**문제점**:
- `simpleHash` 함수가 실제 HMAC-SHA256이 아님
- 단순 해시 함수로 서명을 생성 (보안성 매우 낮음)
- 충돌(collision) 공격에 취약

**영향**:
- 토큰 위조가 쉬움
- 서명 검증이 신뢰할 수 없음

**해결책**:
- 실제 HMAC-SHA256 알고리즘 사용
- Node.js의 `crypto` 모듈 또는 `jsonwebtoken` 라이브러리 사용

---

### 3. **하드코딩된 시크릿 키**
**위치**: `utils/jwt.ts:11`

**문제점**:
- 시크릿 키가 소스 코드에 하드코딩됨
- Git에 커밋되면 누구나 볼 수 있음
- 프로덕션과 개발 환경에서 같은 키 사용

**영향**:
- 키가 노출되면 모든 토큰이 위조 가능
- 환경별 키 분리 불가

**해결책**:
- 환경 변수(`process.env.JWT_SECRET`) 사용
- `.env` 파일을 `.gitignore`에 추가
- 프로덕션과 개발 환경에서 다른 키 사용

---

### 4. **리프레시 토큰 부재**
**위치**: 전체 구현

**문제점**:
- Access Token만 사용 (7일 유효)
- 토큰이 만료되면 다시 로그인해야 함
- 토큰 갱신 메커니즘 없음

**영향**:
- 사용자 경험 저하
- 보안성과 편의성의 균형 문제

**해결책**:
- Access Token (짧은 수명, 예: 15분~1시간)
- Refresh Token (긴 수명, 예: 7일~30일)
- Refresh Token으로 Access Token 갱신

---

## 🟡 보안 취약점

### 5. **쿠키 보안 설정 부족**
**위치**: `composables/useAuth.ts:10-13`

**문제점**:
- `httpOnly` 플래그 없음 → XSS 공격에 취약
- `secure` 플래그 없음 → HTTPS에서만 전송되지 않음
- `sameSite` 설정 없음 → CSRF 공격에 취약

**영향**:
- XSS 공격으로 토큰 탈취 가능
- HTTP에서 토큰 전송 시 중간자 공격 가능
- CSRF 공격 가능

**해결책**:
```typescript
const token = useCookie<string | null>('auth_token', {
  httpOnly: true,      // JavaScript 접근 차단
  secure: true,        // HTTPS에서만 전송
  sameSite: 'strict', // CSRF 방지
  maxAge: 60 * 60 * 24 * 7
})
```

---

### 6. **토큰 만료 처리 미흡**
**위치**: `composables/useAuth.ts:117-122`

**문제점**:
- 토큰 만료 시 자동 갱신 없음
- 만료된 토큰으로 API 호출 시 에러만 발생
- 사용자에게 만료 알림 없음

**영향**:
- 갑작스러운 로그아웃
- 사용자 경험 저하

**해결책**:
- 토큰 만료 전 자동 갱신
- 만료 시 사용자에게 알림
- Refresh Token으로 자동 갱신

---

### 7. **클라이언트 사이드 토큰 검증**
**위치**: `composables/useAuth.ts:100-114`

**문제점**:
- 클라이언트에서 토큰 검증을 수행
- 서버 검증 없이 인증 상태 판단
- 토큰이 위조되어도 클라이언트에서 감지 불가

**영향**:
- 위조된 토큰으로 인증 우회 가능
- 서버 검증과 불일치 가능

**해결책**:
- 클라이언트는 토큰 존재 여부만 확인
- 실제 검증은 서버에서 수행
- `/api/auth/me` 호출로 서버 검증

---

## 🟢 구조적 문제점

### 8. **토큰 저장 방식**
**위치**: `composables/useAuth.ts:10`

**현재**: 쿠키 사용 (양호)

**개선점**:
- `httpOnly` 쿠키 권장 (XSS 방지)
- 또는 메모리 저장 (더 안전하지만 새로고침 시 손실)

---

### 9. **에러 처리 부족**
**위치**: `composables/useAuth.ts:75-79`

**문제점**:
- 토큰 검증 실패 시 에러 타입 구분 없음
- 네트워크 오류와 인증 오류 구분 불가

**해결책**:
- 에러 타입별 처리
- 재시도 로직 추가

---

### 10. **동시성 문제**
**위치**: `composables/useAuth.ts:125-127`

**문제점**:
- 여러 페이지에서 동시에 `fetchUser()` 호출 가능
- 중복 API 호출 발생

**해결책**:
- 요청 중복 방지 (debounce/throttle)
- Promise 캐싱

---

## 📋 권장 개선 사항

### 즉시 수정 필요 (Critical)
1. ✅ JWT 토큰 생성을 서버로 이동
2. ✅ 실제 HMAC-SHA256 알고리즘 사용
3. ✅ 시크릿 키를 환경 변수로 이동
4. ✅ 쿠키 보안 설정 강화 (`httpOnly`, `secure`, `sameSite`)

### 단기 개선 (High Priority)
5. ✅ Refresh Token 구현
6. ✅ 토큰 만료 자동 갱신
7. ✅ 서버 사이드 토큰 검증 강화

### 장기 개선 (Medium Priority)
8. ✅ 에러 처리 개선
9. ✅ 동시성 문제 해결
10. ✅ 토큰 블랙리스트 (로그아웃 시)

---

## 🔐 보안 모범 사례

### JWT 토큰 구조
```
Access Token:
- 수명: 15분 ~ 1시간
- 저장: httpOnly 쿠키 또는 메모리
- 용도: API 인증

Refresh Token:
- 수명: 7일 ~ 30일
- 저장: httpOnly 쿠키
- 용도: Access Token 갱신
```

### 토큰 검증 흐름
1. 클라이언트: 토큰 존재 여부만 확인
2. 서버: 모든 API 요청에서 토큰 검증
3. 만료 시: Refresh Token으로 갱신 시도
4. 갱신 실패 시: 로그인 페이지로 리다이렉트

---

## 📝 결론

현재 구현은 **개발/모킹 목적**으로는 적합하지만, **프로덕션 환경에서는 사용 불가**합니다.

주요 문제:
- 클라이언트 사이드 JWT 생성 (치명적)
- 약한 서명 알고리즘 (치명적)
- 보안 설정 부족 (중요)

**프로덕션 배포 전 반드시 수정 필요**

